<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[0,1]},"content":"<FONT COLOR=\" #21b636 \"><h2> <strong>Perfiladores</strong></h2>","children":[{"type":"heading","depth":1,"payload":{"lines":[2,3]},"content":"<FONT COLOR=\" #1a992b \"><h3>¿Qué es optimización?</h3>","children":[{"type":"heading","depth":2,"payload":{"lines":[4,5]},"content":"Cuando se modifica un programa, se optimiza un algoritmo para que pueda ejecutarse más rápido,<br> o pueda ejecutarse usando menos memoria u otros recursos, o consumir menos energía."},{"type":"heading","depth":2,"payload":{"lines":[6,7]},"content":"<h4><u>Niveles de optimización</u></h4> La elección del algoritmo afecta la eficiencia más que cualquier otro elemento de diseño,<br> y dado que la elección del algoritmo suele ser lo primero que se decide, <br>es difícil argumentar en contra de la &quot;optimización prematura&quot;.","children":[{"type":"heading","depth":3,"payload":{"lines":[8,9]},"content":"<u>Nivel de código fuente:</u> Incluye evitar la codificación de baja calidad, porque de esta manera,<br> se puede mejorar el rendimiento evitando ralentizaciones notorias, en este apartado es muy <br>conveniente para los desarrolladores o desarrolladores escribir código bajo buenas prácticas."},{"type":"heading","depth":3,"payload":{"lines":[10,11]},"content":"<u>Nivel de compilación:</u> Si bien un compilador no es más que un software que traduce un programa<br> escrito a lenguaje de máquina, un compilador generalmente primero genera lenguaje ensamblador<br> y luego traduce el lenguaje ensamblador a lenguaje de máquina. Hay compiladores cruzados,<br> compiladores de optimización y compiladores JIT disponibles para optimizar programas."},{"type":"heading","depth":3,"payload":{"lines":[12,13]},"content":"<u>Nivel de ensamblador:</u> Recordemos, ensamblador es un lenguaje de programación de bajo nivel<br> que representa las instrucciones básicas de computadoras, microprocesadores, microcontroladores<br> y otros circuitos integrados programables. Este nivel está diseñado para una plataforma de hardware<br> específica y puede producir el código más eficiente y compacto si el programador utiliza todo el <br>conjunto de instrucciones de la máquina."},{"type":"heading","depth":3,"payload":{"lines":[14,15]},"content":"<u>Optimización en el tiempo de ejecución:</u> Esto lo hacen los compiladores just in time, y los programadores<br> de ensamblador pueden ir más allá de las capacidades de los compiladores estáticos para realizar<br> optimizaciones de tiempo de ejecución ajustando dinámicamente los parámetros en función de la<br> entrada actual u otros factores. Estos compiladores JIT o just-in-time que mencionábamos van a tomar<br> un papel importante para optimizar."}]}]},{"type":"heading","depth":1,"payload":{"lines":[16,17]},"content":"<FONT COLOR=\"#1a992b\"><h3>Perfiladores</h3>","children":[{"type":"heading","depth":2,"payload":{"lines":[18,19]},"content":"<u><h4>¿Qué hace?</h4></u> Un perfilador recopila información sobre el comportamiento de un programa durante la ejecución del programa.<br> Analiza la aplicación para identificar áreas del programa que se pueden optimizar para aumentar la velocidad general del programa,<br> reducir el uso de memoria, etc. Con esto sabemos que es el “profiling” o perfilado, el cual comúnmente es llamado análisis de rendimiento,<br> y es toda aquella investigación del comportamiento de algún programa computacional, usando información que es reunida desde el análisis dinámico."},{"type":"heading","depth":2,"payload":{"lines":[20,21]},"content":"<u><h4>¿Qué es el análisis dinámico?</h4></u> El análisis dinámico es un tipo de análisis de software que implica ejecutar un programa y observar cómo se comporta, mientras que algunas técnicas<br> de análisis lo hacen sin ejecutar el software para que este tipo de análisis dinámico sea efectivo. <br>El programa a analizar debe ejecutarse con suficientes casos de prueba para producir un comportamiento interesante, y se pueden usar varias pruebas<br> para lograr esto, algunas de las cuales son cobertura de código o programas llamados fuzzing."},{"type":"heading","depth":2,"payload":{"lines":[22,23]},"content":"<u><h4>¿Qué es la cobertura de código?</h4></u> La cobertura de código, también conocida como cobertura de pruebas, mide el grado en que el código fuente de un programa ha sido comprobado con<br> pruebas de software. Sirve para determinar la calidad del test que se lleve a cabo y para determinar las partes críticas del código que no han sido comprobadas<br> y las partes que ya lo fueron, además se puede utilizar como técnica de optimización dentro de un compilador optimizador para llevar a cabo una<br> eliminación de código muerto, más específicamente sirve para detectar código inalcanzable."},{"type":"heading","depth":2,"payload":{"lines":[24,25]},"content":"<u><h4>Código inalcanzable</h4></u> Un código inalcanzable es aquel que nunca podrá ser ejecutado porque no existe ningún camino dentro de las estructuras de control en el resto del programa<br> para llegar a ese código. Suele referirse a este tipo de código como código muerto, aunque entre ellos hay una diferencia (el código muerto se ejecuta pero no<br> produce cambios en la salida del programa. El código inalcanzable generalmente se considera indeseable por las siguiente razones:","children":[{"type":"heading","depth":3,"payload":{"lines":[26,27]},"content":"- Ocupa memoria innecesaria."},{"type":"heading","depth":3,"payload":{"lines":[27,28]},"content":"- Genera almacenamiento innecesario en la caché de<br> instrucciones de la CPU, lo que también disminuye la localidad de datos."},{"type":"heading","depth":3,"payload":{"lines":[28,29]},"content":"- Desde la perspectiva de mantenimiento de software, se pierde tiempo<br> y esfuerzo en mantener y documentar una pieza de código que nunca se ejecuta."}]}]},{"type":"heading","depth":1,"payload":{"lines":[30,31]},"content":"<FONT COLOR=\" #1a992b \"><h3>¿Cómo implementar un perfilador</h3>","children":[{"type":"heading","depth":2,"payload":{"lines":[32,33]},"content":"Primeramente, debemos de tener en cuenta que la arquitectura si hablamos de un sistema, es un insumo fundamental para poder estudiar su performance."},{"type":"heading","depth":2,"payload":{"lines":[34,35]},"content":"Esta arquitectura, es el esqueleto del sistema e influye en los atributos de calidad a evaluar a través de elementos tales como: la interacción entre componentes<br> y su distribución física, las estructuras de control, los protocolos de comunicación, la sincronización, el acceso a los datos."},{"type":"heading","depth":2,"payload":{"lines":[36,37]},"content":"Desde un punto de vista general, la arquitectura va a determinar, entre otras cosas, dónde hay más procesamiento y dónde están los motores de la aplicación<br> y por lo tanto los potenciales cuellos de botella que habrá que estudiar. Existen diversos tipos de arquitecturas como lo son:","children":[{"type":"heading","depth":3,"payload":{"lines":[38,39]},"content":"<u>Monolítica:</u> El software se estructura en grupos funcionales muy acoplados."},{"type":"heading","depth":3,"payload":{"lines":[40,41]},"content":"<u>Cliente-servidor:</u> Formada por un programa (cliente informático) que realiza<br> peticiones a otro programa (el servidor) para obtener cierta respuesta.<br> Uno de los clientes más utilizados, es el navegador web."},{"type":"heading","depth":3,"payload":{"lines":[42,43]},"content":"<u>En capas:</u> Cada una de sus capas tiene responsabilidades definidas y<br> encapsula un conjunto de funcionalidades relacionadas."},{"type":"heading","depth":3,"payload":{"lines":[44,45]},"content":"<u>Cloud Computing:</u> Las aplicaciones del sistema se ejecutan en ambientes<br> remotos, generalmente virtualizados y accesibles a través de Internet;<br> de los cuales no se conoce previamente su ubicación."}]}]}]},{})</script>
</body>
</html>
